<!-- <script src='https://cdn.jsdelivr.net/npm/vue/dist/vue.js'></script> -->
<script src='vue.min.js'></script>
<script src='three.min.js'></script>
<style>
body {
    margin: 0;
}
</style>

<meta charset="UTF-8">

<div id='app'>
    <canvas id='canvas' v-on:mousemove='mouseMove' v-on:mousedown='mouseDown'></canvas>
    <div style='position: fixed;top: 0;left: 0; color: white; padding: 1rem; background-color: #0008'>
        <input type='range' v-model='rx'      min='0.1' max='4' step='0.1'> rx {{rx}}<br>
        <input type='range' v-model='ry'      min='0.1' max='4' step='0.1'> ry {{ry}}<br>
        <input type='range' v-model='mouseRange' min='0.1' max='2' step='0.1'> mouseRange {{mouseRange}}<br>
        <input type='range' v-model='maxItr' min='1' max='1024' step='1'> maxItr {{maxItr}}<br>
        <input type='range' v-model='shadow' min='0.01' max='4' step='0.01'> shadow {{shadow}}<br>
        <input type='range' v-model='d' min='1' max='20' step='1'> d {{d}}<br>
    </div>
</div>

<script type="x-shader/x-fragment" id="fs">
uniform vec2 size, mouse;
uniform float r, mouseRange, shadow, d;
uniform int maxItr;

float julia(vec2 z, vec2 c) {
    vec2 nz;
    int i;
    float x_tmp;
    for(int itr=0;itr<1024;itr++){
        i = itr;
        if(dot(z, z) >= 65536. || itr >= maxItr) break;

        x_tmp = z.x*z.x - z.y*z.y + c.x;
        z.y = 2.*z.x*z.y + c.y;
        z.x = x_tmp;
    }

    float nu = 0.0;
    if(i < maxItr){
        float log_zn = log(dot(z, z)) * 0.5;
        nu = log(log_zn / log(2.0))/log(2.0);
    }

    return (float(i+1)-nu)/float(maxItr);
}

vec4 color(float x) {
    vec4 c1 = vec4(vec3(0., 7., 30.)/255., 0.0);
    vec4 c2 = vec4(vec3(32., 107., 203.)/255., 0.16);
    vec4 c3 = vec4(vec3(237., 255., 255.)/255., 0.42);
    vec4 c4 = vec4(vec3(255., 140., 0.)/255., 0.6425);
    vec4 c5 = vec4(vec3(0., 2., 0.)/255., 0.8575);
    vec4 cr = c1;
    if(x < c1.a){
        cr = c1;
    }else if(x < c2.a){
        cr = mix(c1, c2, (x-c1.a)/(c2.a-c1.a));
    }else if(x < c3.a){
        cr = mix(c2, c3, (x-c2.a)/(c3.a-c2.a));
    }else if(x < c4.a){
        cr = mix(c3, c4, (x-c3.a)/(c4.a-c3.a));
    }else if(x < c5.a){
        cr = mix(c4, c5, (x-c4.a)/(c5.a-c4.a));
    }else{
        cr = mix(c5, c1, (x-c5.a)/(1.0-c5.a));
    }
    return cr;
}

vec4 pattern(float f) {
    f = pow(f, shadow);
    return color(mod(f, 1.0/d)*d);
}

void main() {
    vec2 z = (gl_FragCoord.xy - 0.5*size)*r;
    vec2 c = (mouse - 0.5*size)*r*mouseRange;

    // antialiasing
    float dl = r * 0.5; 
    vec4 col = vec4(0.);
    col += pattern(julia(z+vec2(dl*0., dl*0.), c));
    col += pattern(julia(z+vec2(dl*0., dl*1.), c));
    col += pattern(julia(z+vec2(dl*1., dl*0.), c));
    col += pattern(julia(z+vec2(dl*1., dl*1.), c));
    col *= 0.25;

    // output
    gl_FragColor = col;
}
</script>

<script>

var app = new Vue({
    el: "#app",
    data: {
        canvas: null,
        renderer: null,
        scene: null,
        camera: null,
        sx: null,
        sy: null,
        rx: 3.5,
        ry: 2.5,
        maxItr: 128,
        mouseRange: 0.7,
        shadow: 1.0,
        d: 5.0,
        mouse: true, 
        uniforms: {
        },
    },
    watch: {
        rx: function() {
            this.uniforms.r.value = this.sx*this.ry > this.rx*this.sy ? this.ry/this.sy : this.rx/this.sx;
            this.draw();
        }, 
        ry: function() {
            this.uniforms.r.value = this.sx*this.ry > this.rx*this.sy ? this.ry/this.sy : this.rx/this.sx;
            this.draw();
        },
        maxItr: function() {
            this.uniforms.maxItr.value = this.maxItr;
            this.draw();
        },
        mouseRange: function() {
            this.uniforms.mouseRange.value = this.mouseRange;
            this.draw();
        },
        shadow: function() {
            this.uniforms.shadow.value = this.shadow;
            this.draw();
        },
        d: function() {
            this.uniforms.d.value = this.d;
            this.draw();
        },
    }, 
    mounted: function() {
        this.canvas  = document.getElementById('canvas');
        this.canvas.width  = window.innerWidth;
        this.canvas.height = window.innerHeight;

        // prepare webgl with Three.js
        this.renderer = new THREE.WebGLRenderer({canvas: this.canvas});
        this.scene    = new THREE.Scene();
        this.camera   = new THREE.OrthographicCamera(-0.5, 0.5, 0.5, -0.5, -1, 1);
        this.camera.position.z = 1;
        this.scene.add(this.camera)

        // uniforms for shader
        this.sx = this.canvas.width; 
        this.sy = this.canvas.height;

        this.uniforms = {
            size:       {type: 'v2',    value: new THREE.Vector2(this.sx, this.sy)},
            mouse:      {type: 'v2',    value: new THREE.Vector2(this.sx*0.5, this.sy*0.5)}, 
            r:          {type: 'float', value: this.sx*this.ry > this.rx*this.sy ? this.ry/this.sy : this.rx/this.sx}, 
            maxItr:     {type: 'int',   value: this.maxItr}, 
            mouseRange: {type: 'float', value: this.mouseRange}, 
            shadow:     {type: 'float', value: this.shadow}, 
            d:          {type: 'float', value: this.d}, 
        };

        // prepare shaders
        var screenShaderMaterial = new THREE.ShaderMaterial({
            fragmentShader: document.getElementById('fs').textContent,
            uniforms: this.uniforms,
        });

        // set plane
        var plane = new THREE.PlaneGeometry(1.0, 1.0);
        var mesh = new THREE.Mesh(plane, screenShaderMaterial);
        this.scene.add(mesh);

        // add resize handler
        window.addEventListener('resize', this.resize)
        window.addEventListener('fullscreenchange', this.resize)

        this.draw();
    },
    methods: {
        draw: function() {
            this.renderer.render(this.scene, this.camera);
        },
        mouseMove: function(event) {
            if(this.mouse){
                this.uniforms.mouse.value.x = event.offsetX;
                this.uniforms.mouse.value.y = event.offsetY;
                window.requestAnimationFrame(this.draw);
            }
        }, 
        mouseDown: function() {
            this.mouse = !this.mouse;
        },
        resize: function() {
            this.canvas.width = window.innerWidth;
            this.canvas.height = window.innerHeight;
            this.canvas.style.width = window.innerWidth;
            this.canvas.style.height = window.innerHeight;
            this.sx = window.innerWidth;
            this.sy = window.innerHeight;
            this.uniforms.size.value.x = this.sx;
            this.uniforms.size.value.y = this.sy;
            this.uniforms.r.value = this.sx*this.ry > this.rx*this.sy ? this.ry/this.sy : this.rx/this.sx;
            this.renderer = new THREE.WebGLRenderer({canvas: this.canvas});
            this.draw();
        },
    }, 
});
</script>
