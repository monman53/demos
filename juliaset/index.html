<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/three.js/104/three.min.js'></script>
<style>
body {
    margin: 0;
}
</style>

<meta charset="UTF-8">

<div id='app'>
    <canvas id='canvas' v-on:mousemove='mouseMove'></canvas>
</div>

<script type="x-shader/x-fragment" id="fs">
uniform vec2 size, range, mouse;
uniform float r;

float julia(vec2 z, vec2 c) {
    const int max_itr = 128;
    vec2 nz;
    for(int i=0;i<max_itr;i++){

        if(dot(z, z) > 4.){
            return float(i)/float(max_itr);
        }

        nz.x = z.x*z.x - z.y*z.y + c.x;
        nz.y = 2.*z.x*z.y + c.y;

        // if(z == nz) return 1.0;

        z = nz;
    }
    return 1.0;
}

void main() {
    vec2 z = (gl_FragCoord.xy - 0.5*size)*r;
    vec2 c = (mouse - 0.5*size)*r*0.7;

    // antialiasing
    float dl = r * 0.5; 
    float res = 0.;

    res += julia(z+vec2(dl*0., dl*0.), c);
    res += julia(z+vec2(dl*0., dl*1.), c);
    res += julia(z+vec2(dl*1., dl*0.), c);
    res += julia(z+vec2(dl*1., dl*1.), c);

    res *= 0.25;

    // output
    gl_FragColor = vec4(pow(res, 0.7));
}
</script>

<script>

var app = new Vue({
    el: "#app",
    data: {
        canvas: null,
        renderer: null,
        scene: null,
        camera: null,
        sx: null,
        sy: null,
        rx: null,
        ry: null,
        uniforms: null,
        screenShaderMaterial: null,
        plane: null,
        mesh: null,
    },
    mounted: function() {
        this.canvas  = document.getElementById('canvas');
        this.canvas.width  = window.innerWidth;
        this.canvas.height = window.innerHeight;

        // prepare webgl with Three.js
        this.renderer = new THREE.WebGLRenderer({canvas: this.canvas});
        this.scene    = new THREE.Scene();
        this.camera   = new THREE.OrthographicCamera(-0.5, 0.5, 0.5, -0.5, -1, 1);
        this.camera.position.z = 1;
        this.scene.add(this.camera)

        // uniforms for shader
        this.sx = this.canvas.width; 
        this.sy = this.canvas.height;
        this.rx = 3.5;
        this.ry = 2.5;
        this.uniforms = {
            size:   {type: 'v2',    value: new THREE.Vector2(this.sx, this.sy)},
            mouse:  {type: 'v2',    value: new THREE.Vector2(this.sx*0.5, this.sy*0.5)}, 
            range:  {type: 'v2',    value: new THREE.Vector2(this.rx, this.ry)},
            r:      {type: 'float', value: this.sx*this.ry > this.rx*this.sy ? this.ry/this.sy : this.rx/this.sx}, 
        };

        // prepare shaders
        this.screenShaderMaterial = new THREE.ShaderMaterial({
            fragmentShader: document.getElementById('fs').textContent,
            uniforms: this.uniforms,
        });

        // set plane
        this.plane = new THREE.PlaneGeometry(1.0, 1.0);
        this.mesh = new THREE.Mesh(this.plane, this.screenShaderMaterial);
        this.scene.add(this.mesh);

        this.draw();
    },
    methods: {
        draw: function() {
            this.renderer.render(this.scene, this.camera);
        },
        mouseMove: function(event) {
            this.uniforms.mouse.value.x = event.offsetX;
            this.uniforms.mouse.value.y = event.offsetY;
            window.requestAnimationFrame(this.draw);
        }, 
    }, 
});
</script>
